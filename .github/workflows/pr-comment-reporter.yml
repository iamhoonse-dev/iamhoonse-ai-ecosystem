name: PR Comment Reporter

on:
  workflow_run:
    workflows: ["PR Quality Check", "Security Scan", "CI", "Deploy"]
    types:
      - completed

jobs:
  pr-comment-reporter:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'
    
    steps:
      - name: Get PR number
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            
            if (pullRequests.length === 0) {
              core.setFailed('No open PR found for this branch');
              return;
            }
            
            const prNumber = pullRequests[0].number;
            core.setOutput('pr_number', prNumber);
            return prNumber;

      - name: Get workflow runs for this PR
        id: workflows
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.pr_number }};
            
            // Get all workflow runs for the PR
            const workflowNames = ['PR Quality Check', 'Security Scan', 'CI', 'Deploy'];
            const workflowResults = {};
            
            for (const workflowName of workflowNames) {
              try {
                const { data: workflows } = await github.rest.actions.listRepoWorkflows({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const workflow = workflows.workflows.find(w => w.name === workflowName);
                if (!workflow) continue;
                
                const { data: runs } = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.id,
                  head_sha: context.payload.workflow_run.head_sha
                });
                
                if (runs.workflow_runs.length > 0) {
                  const latestRun = runs.workflow_runs[0];
                  workflowResults[workflowName] = {
                    status: latestRun.status,
                    conclusion: latestRun.conclusion,
                    html_url: latestRun.html_url,
                    run_started_at: latestRun.run_started_at,
                    updated_at: latestRun.updated_at,
                    id: latestRun.id
                  };
                }
              } catch (error) {
                console.error(`Error fetching ${workflowName}:`, error);
              }
            }
            
            core.setOutput('workflow_results', JSON.stringify(workflowResults));
            return workflowResults;

      - name: Get job details for failed workflows
        id: job-details
        uses: actions/github-script@v7
        with:
          script: |
            const workflowResults = JSON.parse('${{ steps.workflows.outputs.workflow_results }}');
            const jobDetails = {};
            
            for (const [workflowName, result] of Object.entries(workflowResults)) {
              if (result.conclusion === 'failure') {
                try {
                  const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: result.id
                  });
                  
                  const failedJobs = jobs.jobs.filter(job => job.conclusion === 'failure');
                  jobDetails[workflowName] = failedJobs.map(job => ({
                    name: job.name,
                    conclusion: job.conclusion,
                    html_url: job.html_url,
                    steps: job.steps?.filter(step => step.conclusion === 'failure').map(step => ({
                      name: step.name,
                      conclusion: step.conclusion
                    })) || []
                  }));
                } catch (error) {
                  console.error(`Error fetching job details for ${workflowName}:`, error);
                }
              }
            }
            
            core.setOutput('job_details', JSON.stringify(jobDetails));
            return jobDetails;

      - name: Create or update PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.pr_number }};
            const workflowResults = JSON.parse('${{ steps.workflows.outputs.workflow_results }}');
            const jobDetails = JSON.parse('${{ steps.job-details.outputs.job_details }}');
            
            // Status emojis
            const statusEmojis = {
              success: 'âœ…',
              failure: 'âŒ',
              cancelled: 'â¹ï¸',
              skipped: 'â­ï¸',
              in_progress: 'ğŸ”„',
              queued: 'â³'
            };
            
            // Workflow descriptions in Korean
            const workflowDescriptions = {
              'PR Quality Check': 'ì½”ë“œ í’ˆì§ˆ ê²€ì‚¬',
              'Security Scan': 'ë³´ì•ˆ ìŠ¤ìº”',
              'CI': 'CI íŒŒì´í”„ë¼ì¸',
              'Deploy': 'ë°°í¬ & ë¶„ì„'
            };
            
            // Build comment body
            let commentBody = `## ğŸš€ PR ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ê²°ê³¼\n\n`;
            commentBody += `**PR ë¸Œëœì¹˜:** \`${context.payload.workflow_run.head_branch}\`\n`;
            commentBody += `**ì»¤ë°‹:** \`${context.payload.workflow_run.head_sha.substring(0, 7)}\`\n`;
            commentBody += `**ì—…ë°ì´íŠ¸ ì‹œê°„:** ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n\n`;
            
            // Overall status
            const allResults = Object.values(workflowResults);
            const hasFailures = allResults.some(r => r.conclusion === 'failure');
            const hasInProgress = allResults.some(r => r.status === 'in_progress' || r.status === 'queued');
            
            if (hasInProgress) {
              commentBody += `### ğŸ”„ ì‹¤í–‰ ì¤‘\nì¼ë¶€ ì›Œí¬í”Œë¡œìš°ê°€ ì•„ì§ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.\n\n`;
            } else if (hasFailures) {
              commentBody += `### âŒ ì‹¤í–‰ ì‹¤íŒ¨\nì¼ë¶€ ì›Œí¬í”Œë¡œìš°ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì•„ë˜ ì„¸ë¶€ì‚¬í•­ì„ í™•ì¸í•´ì£¼ì„¸ìš”.\n\n`;
            } else if (allResults.length > 0 && allResults.every(r => r.conclusion === 'success')) {
              commentBody += `### âœ… ëª¨ë“  ê²€ì‚¬ í†µê³¼\nëª¨ë“  ì›Œí¬í”Œë¡œìš°ê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\n`;
            }
            
            // Individual workflow results
            commentBody += `### ğŸ“‹ ì„¸ë¶€ ì‹¤í–‰ ê²°ê³¼\n\n`;
            
            for (const [workflowName, description] of Object.entries(workflowDescriptions)) {
              const result = workflowResults[workflowName];
              
              if (result) {
                const emoji = statusEmojis[result.conclusion] || statusEmojis[result.status] || 'â“';
                const duration = result.run_started_at && result.updated_at 
                  ? Math.round((new Date(result.updated_at) - new Date(result.run_started_at)) / 1000)
                  : null;
                
                commentBody += `#### ${emoji} ${description}\n`;
                commentBody += `- **ìƒíƒœ:** ${result.conclusion || result.status}\n`;
                if (duration) commentBody += `- **ì‹¤í–‰ ì‹œê°„:** ${duration}ì´ˆ\n`;
                commentBody += `- **ë¡œê·¸:** [ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ê²°ê³¼ ë³´ê¸°](${result.html_url})\n`;
                
                // Add failed job details
                if (result.conclusion === 'failure' && jobDetails[workflowName]) {
                  commentBody += `- **ì‹¤íŒ¨í•œ ì‘ì—…:**\n`;
                  for (const job of jobDetails[workflowName]) {
                    commentBody += `  - ğŸ”— [${job.name}](${job.html_url})\n`;
                    if (job.steps.length > 0) {
                      commentBody += `    - ì‹¤íŒ¨í•œ ë‹¨ê³„: ${job.steps.map(s => s.name).join(', ')}\n`;
                    }
                  }
                }
                commentBody += `\n`;
              } else {
                commentBody += `#### â­ï¸ ${description}\n`;
                commentBody += `- **ìƒíƒœ:** ì‹¤í–‰ë˜ì§€ ì•ŠìŒ (ì¡°ê±´ì— ë§ì§€ ì•ŠìŒ)\n\n`;
              }
            }
            
            // Add helpful information for failures
            if (hasFailures) {
              commentBody += `### ğŸ› ï¸ ë¬¸ì œ í•´ê²° ê°€ì´ë“œ\n\n`;
              
              if (workflowResults['PR Quality Check']?.conclusion === 'failure') {
                commentBody += `#### ì½”ë“œ í’ˆì§ˆ ê²€ì‚¬ ì‹¤íŒ¨\n`;
                commentBody += `- **ESLint ì˜¤ë¥˜:** \`pnpm lint\`ë¡œ ë¡œì»¬ì—ì„œ í™•ì¸í•˜ê³  \`pnpm lint:fix\`ë¡œ ìë™ ìˆ˜ì •\n`;
                commentBody += `- **TypeScript ì˜¤ë¥˜:** \`pnpm check-types\`ë¡œ íƒ€ì… ì˜¤ë¥˜ í™•ì¸\n`;
                commentBody += `- **í¬ë§·íŒ… ì˜¤ë¥˜:** \`pnpm format\`ë¡œ ì½”ë“œ í¬ë§·íŒ… ìˆ˜ì •\n`;
                commentBody += `- **ë¹Œë“œ ì‹¤íŒ¨:** ì˜ì¡´ì„±ì´ë‚˜ êµ¬ë¬¸ ì˜¤ë¥˜ í™•ì¸\n\n`;
              }
              
              if (workflowResults['Security Scan']?.conclusion === 'failure') {
                commentBody += `#### ë³´ì•ˆ ìŠ¤ìº” ì‹¤íŒ¨\n`;
                commentBody += `- **ì˜ì¡´ì„± ì·¨ì•½ì :** \`pnpm audit\`ë¡œ í™•ì¸í•˜ê³  \`pnpm audit --fix\`ë¡œ ìˆ˜ì •\n`;
                commentBody += `- **CodeQL ê²½ê³ :** ì½”ë“œ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì—¬ ë³´ì•ˆ ì´ìŠˆ í•´ê²°\n`;
                commentBody += `- **ì‹œí¬ë¦¿ ìŠ¤ìº”:** í•˜ë“œì½”ë”©ëœ API í‚¤ë‚˜ ë¯¼ê°í•œ ì •ë³´ ì œê±°\n\n`;
              }
              
              if (workflowResults['CI']?.conclusion === 'failure') {
                commentBody += `#### CI íŒŒì´í”„ë¼ì¸ ì‹¤íŒ¨\n`;
                commentBody += `- **í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨:** ë¡œì»¬ì—ì„œ \`pnpm test\` ì‹¤í–‰í•˜ì—¬ í™•ì¸\n`;
                commentBody += `- **ë¹Œë“œ ì˜¤ë¥˜:** ê° íŒ¨í‚¤ì§€ë³„ë¡œ \`pnpm build\` ì‹¤í–‰í•˜ì—¬ í™•ì¸\n`;
                commentBody += `- **ì˜ì¡´ì„± ì˜¤ë¥˜:** \`pnpm install\` ì¬ì‹¤í–‰\n\n`;
              }
            }
            
            // Success metrics
            if (allResults.length > 0 && allResults.every(r => r.conclusion === 'success')) {
              commentBody += `### ğŸ“Š ì„±ê³¼ ì§€í‘œ\n\n`;
              const totalDuration = allResults
                .filter(r => r.run_started_at && r.updated_at)
                .reduce((sum, r) => sum + (new Date(r.updated_at) - new Date(r.run_started_at)), 0);
              
              if (totalDuration > 0) {
                commentBody += `- **ì „ì²´ ì‹¤í–‰ ì‹œê°„:** ${Math.round(totalDuration / 1000)}ì´ˆ\n`;
              }
              commentBody += `- **ì‹¤í–‰ëœ ì›Œí¬í”Œë¡œìš°:** ${Object.keys(workflowResults).length}ê°œ\n`;
              commentBody += `- **í’ˆì§ˆ ê²€ì‚¬:** í†µê³¼ âœ…\n`;
              commentBody += `- **ë³´ì•ˆ ê²€ì‚¬:** í†µê³¼ ğŸ›¡ï¸\n`;
              commentBody += `- **ë¹Œë“œ ê²€ì‚¬:** í†µê³¼ ğŸ”¨\n\n`;
            }
            
            commentBody += `---\n`;
            commentBody += `*ì´ ì½”ë©˜íŠ¸ëŠ” GitHub Actionsì— ì˜í•´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.*`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const existingComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ğŸš€ PR ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ê²°ê³¼')
            );
            
            // Create or update comment
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
              console.log('Updated existing PR comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
              console.log('Created new PR comment');
            }