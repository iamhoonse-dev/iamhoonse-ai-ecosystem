name: Security Scan

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0' # Weekly on Sundays

jobs:
  codeql-analysis:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript', 'typescript' ]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"

  dependency-scan:
    name: Dependency Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run security audit
        run: pnpm audit --audit-level high

      - name: Check for known vulnerabilities
        run: |
          if command -v audit-ci &> /dev/null; then
            npx audit-ci --config audit-ci.json
          else
            echo "audit-ci not installed, skipping detailed vulnerability check"
          fi
        continue-on-error: true

  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run TruffleHog OSS
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

  security-report:
    name: Security Report
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [codeql-analysis, dependency-scan, secret-scan]
    
    steps:
      - name: Generate security summary
        uses: actions/github-script@v7
        with:
          script: |
            // Create security report for PR comment
            let securityReport = `## 🛡️ 보안 스캔 결과\n\n`;
            securityReport += `**스캔 대상:** \`${context.payload.pull_request.head.ref}\` 브랜치\n`;
            securityReport += `**스캔 시간:** ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n\n`;
            
            // Check job statuses
            const jobs = ['codeql-analysis', 'dependency-scan', 'secret-scan'];
            const jobResults = {};
            
            try {
              // Get workflow run for this PR
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'security-scan.yml',
                head_sha: context.payload.pull_request.head.sha
              });
              
              if (runs.workflow_runs.length > 0) {
                const runId = runs.workflow_runs[0].id;
                const { data: runJobs } = await github.rest.actions.listJobsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId
                });
                
                for (const job of runJobs.jobs) {
                  jobResults[job.name] = {
                    status: job.status,
                    conclusion: job.conclusion,
                    html_url: job.html_url
                  };
                }
              }
            } catch (error) {
              console.error('Error fetching job results:', error);
            }
            
            // CodeQL Analysis
            securityReport += `### 🔍 CodeQL 정적 분석\n`;
            const codeqlResult = jobResults['CodeQL Analysis'];
            if (codeqlResult) {
              const emoji = codeqlResult.conclusion === 'success' ? '✅' : 
                           codeqlResult.conclusion === 'failure' ? '❌' : '🔄';
              securityReport += `- **상태:** ${emoji} ${codeqlResult.conclusion || codeqlResult.status}\n`;
              securityReport += `- **분석 언어:** JavaScript, TypeScript\n`;
              securityReport += `- **로그:** [CodeQL 분석 결과 보기](${codeqlResult.html_url})\n`;
              
              if (codeqlResult.conclusion === 'success') {
                securityReport += `- **결과:** 보안 취약점이 발견되지 않았습니다\n`;
              } else if (codeqlResult.conclusion === 'failure') {
                securityReport += `- **결과:** 보안 취약점이 발견되었을 수 있습니다. 상세 결과를 확인해주세요\n`;
              }
            } else {
              securityReport += `- **상태:** ⏭️ 실행되지 않음\n`;
            }
            
            // Dependency Scan
            securityReport += `\n### 📦 의존성 보안 스캔\n`;
            const depResult = jobResults['Dependency Security Scan'];
            if (depResult) {
              const emoji = depResult.conclusion === 'success' ? '✅' : 
                           depResult.conclusion === 'failure' ? '❌' : '🔄';
              securityReport += `- **상태:** ${emoji} ${depResult.conclusion || depResult.status}\n`;
              securityReport += `- **검사 도구:** pnpm audit, audit-ci\n`;
              securityReport += `- **로그:** [의존성 스캔 결과 보기](${depResult.html_url})\n`;
              
              if (depResult.conclusion === 'success') {
                securityReport += `- **결과:** 고위험 취약점이 발견되지 않았습니다\n`;
              } else if (depResult.conclusion === 'failure') {
                securityReport += `- **결과:** 보안 취약점이 발견되었습니다. 의존성 업데이트가 필요합니다\n`;
              }
            } else {
              securityReport += `- **상태:** ⏭️ 실행되지 않음\n`;
            }
            
            // Secret Scan
            securityReport += `\n### 🔐 시크릿 스캔\n`;
            const secretResult = jobResults['Secret Scanning'];
            if (secretResult) {
              const emoji = secretResult.conclusion === 'success' ? '✅' : 
                           secretResult.conclusion === 'failure' ? '❌' : '🔄';
              securityReport += `- **상태:** ${emoji} ${secretResult.conclusion || secretResult.status}\n`;
              securityReport += `- **검사 도구:** TruffleHog OSS\n`;
              securityReport += `- **로그:** [시크릿 스캔 결과 보기](${secretResult.html_url})\n`;
              
              if (secretResult.conclusion === 'success') {
                securityReport += `- **결과:** 하드코딩된 시크릿이 발견되지 않았습니다\n`;
              } else if (secretResult.conclusion === 'failure') {
                securityReport += `- **결과:** 잠재적 시크릿이 발견되었습니다. 즉시 확인이 필요합니다\n`;
              }
            } else {
              securityReport += `- **상태:** ⏭️ 실행되지 않음\n`;
            }
            
            // Security recommendations
            securityReport += `\n### 🚨 보안 권장사항\n`;
            securityReport += `- 모든 의존성을 최신 보안 패치 버전으로 유지하세요\n`;
            securityReport += `- API 키, 비밀번호 등은 환경변수나 시크릿 매니저를 사용하세요\n`;
            securityReport += `- 정기적으로 보안 스캔을 실행하여 새로운 취약점을 확인하세요\n`;
            securityReport += `- 코드 리뷰 시 보안 관점에서의 검토를 포함하세요\n`;
            
            // Overall security status
            const hasFailures = Object.values(jobResults).some(r => r.conclusion === 'failure');
            const hasInProgress = Object.values(jobResults).some(r => r.status === 'in_progress' || r.status === 'queued');
            
            if (hasInProgress) {
              securityReport = `### 🔄 보안 스캔 진행 중\n일부 보안 검사가 아직 진행 중입니다.\n\n` + securityReport;
            } else if (hasFailures) {
              securityReport = `### ❌ 보안 이슈 발견\n일부 보안 검사에서 이슈가 발견되었습니다. 즉시 확인하여 조치해주세요.\n\n` + securityReport;
            } else if (Object.keys(jobResults).length > 0) {
              securityReport = `### ✅ 보안 검사 통과\n모든 보안 검사가 성공적으로 완료되었습니다.\n\n` + securityReport;
            }
            
            // Find existing security comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const existingComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('🛡️ 보안 스캔 결과')
            );
            
            const commentBody = securityReport + '\n\n---\n*보안 스캔 결과는 GitHub Actions에 의해 자동으로 생성되었습니다.*';
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
              console.log('Updated existing security comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new security comment');
            }
        continue-on-error: true